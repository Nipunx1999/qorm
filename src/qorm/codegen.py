"""Code generation — introspect kdb+ tables and write typed model files."""

from __future__ import annotations

import os
from pathlib import Path
from typing import TYPE_CHECKING

from .protocol.constants import QTypeCode

if TYPE_CHECKING:
    from .engine import Engine

# ── QTypeCode → qorm.types alias name ────────────────────────────────

_QTYPE_TO_ALIAS: dict[QTypeCode, str] = {
    QTypeCode.BOOLEAN: "Boolean",
    QTypeCode.GUID: "Guid",
    QTypeCode.BYTE: "Byte",
    QTypeCode.SHORT: "Short",
    QTypeCode.INT: "Int",
    QTypeCode.LONG: "Long",
    QTypeCode.REAL: "Real",
    QTypeCode.FLOAT: "Float",
    QTypeCode.CHAR: "Char",
    QTypeCode.SYMBOL: "Symbol",
    QTypeCode.TIMESTAMP: "Timestamp",
    QTypeCode.MONTH: "Month",
    QTypeCode.DATE: "Date",
    QTypeCode.DATETIME: "DateTime",
    QTypeCode.TIMESPAN: "Timespan",
    QTypeCode.MINUTE: "Minute",
    QTypeCode.SECOND: "Second",
    QTypeCode.TIME: "Time",
    QTypeCode.MIXED_LIST: "List",
}


def _class_name(tablename: str) -> str:
    """Convert a table name to a PascalCase class name.

    ``trade`` → ``Trade``, ``daily_price`` → ``DailyPrice``.
    """
    return "".join(part.capitalize() for part in tablename.split("_"))


def generate_model_source(
    tablename: str,
    fields: list[tuple[str, QTypeCode]],
    key_fields: list[str] | None = None,
) -> str:
    """Generate Python source for a single model file.

    Parameters
    ----------
    tablename:
        The kdb+ table name.
    fields:
        Ordered list of ``(column_name, QTypeCode)`` pairs.
    key_fields:
        Column names that form the primary key (keyed table).

    Returns
    -------
    str
        Complete Python source for the model module.
    """
    key_set = set(key_fields) if key_fields else set()
    base_class = "KeyedModel" if key_set else "Model"

    # Collect the set of type aliases used
    type_aliases: set[str] = set()
    for _, code in fields:
        alias = _QTYPE_TO_ALIAS.get(code)
        if alias:
            type_aliases.add(alias)

    # Build imports
    imports = [f"from qorm import {base_class}"]
    if type_aliases:
        sorted_aliases = sorted(type_aliases)
        imports.append(f"from qorm.types import {', '.join(sorted_aliases)}")

    if key_set:
        imports.append("from qorm import field")

    cls_name = _class_name(tablename)

    lines: list[str] = []
    lines.append('"""Auto-generated by qorm. Do not edit."""')
    lines.append("")
    for imp in imports:
        lines.append(imp)
    lines.append("")
    lines.append("")
    lines.append(f"class {cls_name}({base_class}):")
    lines.append(f"    __tablename__ = {tablename!r}")

    for col_name, code in fields:
        alias = _QTYPE_TO_ALIAS.get(code, "List")
        if col_name in key_set:
            lines.append(f"    {col_name}: {alias} = field(primary_key=True)")
        else:
            lines.append(f"    {col_name}: {alias}")

    lines.append("")
    return "\n".join(lines)


def generate_init_source(models: list[tuple[str, str]]) -> str:
    """Generate ``__init__.py`` source that re-exports all model classes.

    Parameters
    ----------
    models:
        List of ``(tablename, module_name)`` pairs — *module_name* is the
        file stem (e.g. ``"fxtrades"``).
    """
    lines: list[str] = []
    lines.append('"""Auto-generated by qorm. Do not edit."""')
    lines.append("")
    for tablename, module_name in models:
        cls_name = _class_name(tablename)
        lines.append(f"from .{module_name} import {cls_name}")
    lines.append("")
    return "\n".join(lines)


def generate_models(
    engine: Engine,
    output_dir: str | Path,
    table_names: list[str],
) -> list[str]:
    """Connect to kdb+, reflect tables, and write model files.

    Parameters
    ----------
    engine:
        A configured :class:`Engine` pointing at the kdb+ process.
    output_dir:
        Directory to write the generated model package into.
    table_names:
        Table names to introspect.

    Returns
    -------
    list[str]
        Paths of generated files.
    """
    from .session import Session

    output = Path(output_dir)
    output.mkdir(parents=True, exist_ok=True)

    generated: list[str] = []
    model_entries: list[tuple[str, str]] = []  # (tablename, module_name)

    with Session(engine) as s:
        for tablename in table_names:
            model_cls = s.reflect(tablename)

            # Extract (col_name, QTypeCode) from reflected fields
            fields: list[tuple[str, QTypeCode]] = []
            for name, fld in model_cls.__fields__.items():
                code = fld.qtype.code if fld.qtype else QTypeCode.MIXED_LIST
                fields.append((name, code))

            key_fields = list(model_cls.__key_fields__) if model_cls.__key_fields__ else None

            source = generate_model_source(tablename, fields, key_fields)
            module_name = tablename  # file stem = table name
            filepath = output / f"{module_name}.py"
            filepath.write_text(source, encoding="utf-8")
            generated.append(str(filepath))
            model_entries.append((tablename, module_name))

    # Write __init__.py
    init_source = generate_init_source(model_entries)
    init_path = output / "__init__.py"
    init_path.write_text(init_source, encoding="utf-8")
    generated.append(str(init_path))

    return generated
